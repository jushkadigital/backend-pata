version: '3.8'

services:
  # ----------------------------------------------------------------
  # 1. TU APLICACIÓN QUARKUS
  # ----------------------------------------------------------------
  app:
    image: urgosxd7/mi-app-prod:v1
    container_name: quarkus-app-prod
    restart: always
    environment:
      # Conexión interna: Dentro de Docker, Keycloak sigue escuchando en el 8080
      - KEYCLOAK_INTERNAL_URL=http://keycloak-prod:8080
      
      - KEYCLOAK_ADMIN_USER=${KEYCLOAK_ADMIN:-admin}
      - KEYCLOAK_ADMIN_PASSWORD=${KEYCLOAK_ADMIN_PASSWORD:-admin}
      - QUARKUS_OIDC_TOKEN_ISSUER=any
      
      # Base de datos
      - QUARKUS_DATASOURCE_JDBC_URL=jdbc:postgresql://postgres:5432/keycloak
      - QUARKUS_DATASOURCE_USERNAME=keycloak
      - QUARKUS_DATASOURCE_PASSWORD=keycloak
    expose:
      - "8081"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - prod-network
      - red-compartida
      - proxiable


  # ----------------------------------------------------------------
  # 2. BASE DE DATOS (POSTGRES)
  # ----------------------------------------------------------------
  postgres:
    image: postgres:15
    container_name: postgres-prod
    restart: always
    environment:
      POSTGRES_DB: keycloak
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: keycloak
      
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-postgres}"]  # Usa defaults si no seteados
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 20s
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - prod-network

  # ----------------------------------------------------------------
  # 3. KEYCLOAK (PhaseTwo)
  # ----------------------------------------------------------------
  keycloak:
    image: quay.io/phasetwo/phasetwo-keycloak:26.4.2
    container_name: keycloak-prod
    restart: always
    environment:
      # ... (Tus credenciales de DB y Admin aquí) ...
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: keycloak
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
      
      # 1. ACTIVACIÓN DE FUNCIONALIDADES
      # Esto equivale a ejecutar el "build --health-enabled" que leíste
      KC_HEALTH_ENABLED: true
      KC_METRICS_ENABLED: true 
      
      # Configuración HTTP
      KC_HTTP_ENABLED: true
      KC_HOSTNAME_STRICT: false
      KC_HOSTNAME_STRICT_HTTPS: false
      
    # 2. HEALTHCHECK "A PRUEBA DE BALAS"
    # La documentación dice que 'curl' puede no estar. 
    # Este comando usa Bash puro para intentar abrir una conexión al puerto 8080.
    # Si conecta, devuelve éxito (exit 0). Si falla, da error (exit 1).

    depends_on:
      postgres:
        condition: service_healthy
    expose:
      - "8080"
        
    # 3. EL TRUCO DEL COMMAND
    # Al quitar '--optimized', obligamos a Keycloak a leer las variables KC_..._ENABLED
    # y auto-configurarse al arrancar. Tardará unos segundos más en iniciar, pero funcionará.
    entrypoint: ["/bin/sh"]
    command: -c "/opt/keycloak/bin/kc.sh build && exec /opt/keycloak/bin/kc.sh start --optimized --log-level=ERROR,FATAL"

    networks:
      - prod-network
    
volumes:
  postgres_data:

networks:
  proxiable:
    external: true
    name: proxiable # Asegúrate de que este nombre coincida exactamente con tu red externa
  prod-network:
    driver: bridge
  red-compartida:
    external: true      # <--- ¡ESTO ES LO IMPORTANTE!
    name: red-compartida # Asegura que busque el nombre exacto
